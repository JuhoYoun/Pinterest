
def hello_world(request):
    # return HttpResponse("Hello World")
    if request.user.is_authenticated:
        if request.method == "POST":

            temp = request.POST.get('hello_world_input')

            new_hello_world = HelloWorld()
            new_hello_world.text = temp
            new_hello_world.save()

            return HttpResponseRedirect(reverse('accountapp:hello_world'))
        else:
            # return render(request, 'accountapp/hello_world.html', context={'text': 'GET METHOD!!!'})
            hello_world_list = HelloWorld.objects.all()
            return render(request, 'accountapp/hello_world.html', context={'hello_world_list': hello_world_list})
    else:
        return HttpResponseRedirect(reverse('accountapp:login'))
   
   
위와 같은 function based view 에서는 if request.method == "POST": 이부분처럼 Post 일때와 get 일때 어떻게 동작할지 나눠논거처럼 class based view 에서는 클래스 내부의
method 를 통해 동작을 지정할 수 있다. 

class AccountUpdateView(UpdateView):
    model = User
    context_object_name = 'target_user'
    form_class = AccountUpdateForm
    success_url = reverse_lazy('accountapp:hello_world')  # 계정 만드는데 성공했다면 어느 URL로 redirect 될것인가
    template_name = 'accountapp/update.html'

    def get(self, *args, **kwargs):
        if self.request.user.is_authenticated:
            return super().get(*args, **kwargs)
        else:
            return HttpResponseRedirect(reverse('accountapp:login'))

    def post(self, *args, **kwargs):
        if self.request.user.is_authenticated:
            return super().get(*args, **kwargs)
        else:
            return HttpResponseRedirect(reverse('accountapp:login'))

AccountUpdateView 내부에 메소드를 다음과 같이 넣고 AccountDeleteView 에도 동일하게 추가하자. 지금 하는 부분은 사실 나중에 다 바꿀 부분이긴하다.
이렇게 하면 update 와 delete 기능에 인증기능을 추가한것이다. 하지만 여기에 한가지 문제가 있다. 일단 한계정으로 로그인만 하면 다른계정의 update와 delete 페이지를 들어갈수 있다. 
이를 막기 위해 다음과 같이 고치자

class AccountUpdateView(UpdateView):
    model = User
    context_object_name = 'target_user'
    form_class = AccountUpdateForm
    success_url = reverse_lazy('accountapp:hello_world')  # 계정 만드는데 성공했다면 어느 URL로 redirect 될것인가
    template_name = 'accountapp/update.html'

    def get(self, *args, **kwargs):
        if self.request.user.is_authenticated and self.get_object() == self.request.user:
            return super().get(*args, **kwargs)
        else:
            return HttpResponseRedirect(reverse('accountapp:login'))

    def post(self, *args, **kwargs):
        if self.request.user.is_authenticated and self.get_object() == self.request.user:
            return super().get(*args, **kwargs)
        else:
            return HttpResponseRedirect(reverse('accountapp:login'))
      
self.get_object()는 path('update/<int:pk>', AccountUpdateView.as_view(), name='update'), 이와 같이 pk로 넘겨받은 값에 해당하는 모델 객체를 반환한다


class AccountUpdateView(UpdateView):
    model = User
    context_object_name = 'target_user'
    form_class = AccountUpdateForm
    success_url = reverse_lazy('accountapp:hello_world')  # 계정 만드는데 성공했다면 어느 URL로 redirect 될것인가
    template_name = 'accountapp/update.html'

    def get(self, *args, **kwargs):
        if self.request.user.is_authenticated and self.get_object() == self.request.user:
            return super().get(*args, **kwargs)
        else:
            return HttpResponseForbidden()

    def post(self, *args, **kwargs):
        if self.request.user.is_authenticated and self.get_object() == self.request.user:
            return super().get(*args, **kwargs)
        else:
            return HttpResponseForbidden()
  
Redirect 하지말고 forbidden page를 띄어주자. 

이렇게 코드를 짰지만 return 문이 너무 많은듯 너무 복잡한거같다. -> decorator 를 사용하여 바꿔보자.
decorator는 어떤 함수를 받아서 앞이나 뒤를 꾸며준다.
ex)
def decorator(func):
    def decorated(func):
        print(datetime.now())
        func()
        print(datetime.now())
    return decorated
    
이 decorator를 사용하면

def function1():
    print(datetime.now())
    print("Function 1 Start") 
    print(datetime.now())
    
def function2():
    print(datetime.now())
    print("Function 2 Start") 
    print(datetime.now())

def function3():
    print(datetime.now())
    print("Function 3 Start") 
    print(datetime.now())

이 세 함수들을
->

@decorator
def function1():
    print("Function 1 Start") 


@decorator
def function2():
    print("Function 2 Start") 


@decorator
def function3():
    print("Function 3 Start") 

이렇게 간단히 할 수 있다.

다음은 Chatgpt

데코레이터(Decorator)는 파이썬에서 기본적으로 제공되는 기능입니다. 데코레이터는 파이썬에서 함수나 클래스를 수정하거나, 추가적인 기능을 덧붙일 때 사용됩니다. 데코레이터는 함수나 클래스 위에 @ 기호를 사용하여 적용하며, 간단하게 코드를 수정하거나 덧붙일 수 있습니다.

Django에서는 파이썬의 데코레이터를 이용하여 편리한 기능들을 추가하고 있습니다. 예를 들어, @login_required 데코레이터를 사용하면 로그인한 사용자만 접근할 수 있는 뷰를 만들 수 있습니다. 또한, @cache_page 데코레이터를 사용하면 캐시를 이용하여 뷰의 성능을 향상시킬 수 있습니다.

따라서, 데코레이터는 파이썬에서 제공되는 기본적인 기능이지만, Django에서는 특정 기능들을 더욱 편리하게 사용할 수 있도록 데코레이터를 추가하고 있습니다.

hello_world 뷰를 @login_required를 이용해 바꿔보자

def hello_world(request):
    # return HttpResponse("Hello World")
    if request.user.is_authenticated:
        if request.method == "POST":

            temp = request.POST.get('hello_world_input')

            new_hello_world = HelloWorld()
            new_hello_world.text = temp
            new_hello_world.save()

            return HttpResponseRedirect(reverse('accountapp:hello_world'))
        else:
            # return render(request, 'accountapp/hello_world.html', context={'text': 'GET METHOD!!!'})
            hello_world_list = HelloWorld.objects.all()
            return render(request, 'accountapp/hello_world.html', context={'hello_world_list': hello_world_list})
    else:
        return HttpResponseRedirect(reverse('accountapp:login'))
 
 ->
 
 @login_required
def hello_world(request):
    # return HttpResponse("Hello World")
    if request.method == "POST":

        temp = request.POST.get('hello_world_input')

        new_hello_world = HelloWorld()
        new_hello_world.text = temp
        new_hello_world.save()

        return HttpResponseRedirect(reverse('accountapp:hello_world'))
    else:
        # return render(request, 'accountapp/hello_world.html', context={'text': 'GET METHOD!!!'})
        hello_world_list = HelloWorld.objects.all()
        return render(request, 'accountapp/hello_world.html', context={'hello_world_list': hello_world_list})

간단하당

이런 데코레이터를 클래스 내부에 있는 메소드에 적용하려고 한다.

@method_decorator(login_required, 'get')
@method_decorator(login_required, 'post')
class AccountUpdateView(UpdateView):
    model = User
    context_object_name = 'target_user'
    form_class = AccountUpdateForm
    success_url = reverse_lazy('accountapp:hello_world')  # 계정 만드는데 성공했다면 어느 URL로 redirect 될것인가
    template_name = 'accountapp/update.html'

이런식으로 할 수 있다.
accoutapp 디렉토리에 decorators.py 파일을 만들어 커스텀 데코레이터를 만들자.

from django.contrib.auth.models import User
from django.http import HttpResponseForbidden


def account_ownership_required(func):
    def decorated(request, *args, **kwargs):
        user = User.objects.get(pk=kwargs['pk'])
        if not user == request.user:
            return HttpResponseForbidden()
        return func(request, *args, **kwargs)

    return decorated

그리고 이를 이용해서 view에 데코레이터를 추가하자
->
@method_decorator(login_required, 'get')
@method_decorator(login_required, 'post')
@method_decorator(account_ownership_required, 'get')
@method_decorator(account_ownership_required, 'post')
class AccountUpdateView(UpdateView):
    model = User
    context_object_name = 'target_user'
    form_class = AccountUpdateForm
    success_url = reverse_lazy('accountapp:hello_world')  # 계정 만드는데 성공했다면 어느 URL로 redirect 될것인가
    template_name = 'accountapp/update.html'
    
이러면 위의 코드는 이전의 데코레이터를 사용하기 전의 코드와 동일하지만 더 간단해진다.


