AWS 과금 주의 
모든 것에 대해 돈을 내라 하고 졸라 비싸다 

추가적인 강의

1. AWS EC2 Deployment - 우리가 했던 과정을 VULTR 말고 AWS 에서 다시 해보기
2. Domain Configuration - 도메인을 사서 해당 도메인을 AWS EC2 instance 와 연결한다
3. HTTPS Configuration - HTTPS 보안 기능 
4. Github Private Repo - github repo를 private으로 돌렸을 우리가 해왔던 과정에 어떤 문제가 생기는지 ... 클론이나 그런 기능들을 하던 방식대로 사용할 수 없다
5. Like System Update - 좋아요 기능 추가 


AWS EC2 Deployment
 
VULTR의 경우 ssh로 접속할 때 id와 password를 인자로 넘겨줘 해당 서버에 접속했다 AWS에서는 보안상 PEM 같은 key file을 이용해서 서버에 접속하는것이 권장된다 (id/password 도 되긴한다)
VULTR에서는 도커가 이미 깔려있는 서버를 대여 받아 시작했지만 AWS 에는 도커가 깔려 있지 않아 직접 깔아줘야한다 
AWS도 포트가 있는데 default로 이 포트들이 방화벽으로 (firewall) 모두 막혀있다 때문에 포트를 사용해야할 때 포트를 열어주는 설정을 해줘야한다

일단 AWS 로 가서 콘솔 로그인을 한 다음 service -> EC2로 가자 
인스턴스를 만들기 이전에 key file을 먼저 만들어주자 좌측의 Network & Security 로 가서 Key pairs를 클릭 create key pair 를 누르고 pem 키를 만들어준다 이름은 맘대로 한다 
키 생성 동시에 pem 파일이 다운로드 된다 이 파일을 로컬의 프로젝트 루트 디렉토리로 옮기자 그리고 이 경로에서 ssh 접속을 할 수 있게 구축할것이다 (뭔말?)
그리고 instances 로 가서 launch instance를 누른다 ubuntu 20.0.4 를 선택 다른 것들 기본값으로 해준다 강의에서 보안 그룹 설정 단계가 포트를 관리하는 방화벽 설정 부분인데 지금 AWS 랑 다른가 보다 나한테 안보인다 
강의에서 포트는 우리가 필요할 때 마다 그 때 그 때 열어주기로 했다 키는 아까 만들었던 pem 키를 선택한다 그리고 인스턴스 시작해준다 

자 그러면 다운 받았던 pem 키를 이용해서 ssh 접속을 해보자 pem 키를 다운받았던 디렉토리로 가서 다음 명령어를 사용하낟
-> ssh -i aws_jake.pem ubuntu@54.215.96.40
ssh 로 pem 파일을 이용해 ubuntu 유저로 aws 주소로 접근한다는 의미이다 
#####
AWS EC2에서는 인스턴스에 따라 기본 사용자 이름이 다릅니다. Ubuntu 인스턴스의 경우, 기본 사용자 이름은 'ubuntu'이며, 이 계정을 통해 ssh 접속할 수 있습니다.

일반적으로 AWS EC2 인스턴스는 'root' 계정을 직접 사용하지 못하게 설정되어 있습니다. 대신, sudo 명령어를 사용하여 'ubuntu' 또는 다른 사용자 계정에서 root 권한을 얻을 수 있습니다
#####
그러면 지금은 처음 시도하는 거라서

The authenticity of host '54.215.96.40 (54.215.96.40)' can't be established.
ED25519 key fingerprint is SHA256:OOvvGghl080csg1bicigc3NpgNA511NFUAUXi5VYJBo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? 

이렇게 메세지가 뜬다 yes 를 타입해 접속하자
강의에서는 이러면 접속 되는데 나는 아래와 같은 에러 메세지가 뜬다
#########
The authenticity of host '54.215.96.40 (54.215.96.40)' can't be established.
ED25519 key fingerprint is SHA256:OOvvGghl080csg1bicigc3NpgNA511NFUAUXi5VYJBo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '54.215.96.40' (ED25519) to the list of known hosts.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions 0644 for 'aws_jake.pem' are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
Load key "aws_jake.pem": bad permissions
ubuntu@54.215.96.40: Permission denied (publickey).
##########
##########
위의 문제에 대한 chatgpt 해결법 진짜 먹힌다

이 오류 메시지는 개인키 파일의 권한이 너무 개방적으로 설정되어 있어, AWS가 이를 안전하지 않다고 판단한 것을 나타냅니다. AWS는 이 파일이 현재 사용자에게만 읽기 권한을 부여하도록 요구합니다.

이 문제를 해결하기 위해서는 파일 권한을 변경해야 합니다. 현재 사용자만이 이 파일을 읽을 수 있도록 파일 권한을 400 또는 600으로 설정하면 됩니다.

리눅스나 MacOS에서 다음 명령어를 실행하면 이를 수행할 수 있습니다:

bash
Copy code
chmod 400 aws_jake.pem
이 명령어를 실행한 후 다시 SSH 연결을 시도해보세요. 이제 AWS EC2 인스턴스에 연결할 수 있어야 합니다.
###############

연결되면 일단 도커가 깔려 있는지 확인한다 
-> sudo docker 또는 docker
도커가 안깔려 있는걸 볼 수 있다 도커를 깔아줘야한다

#######
chat gpt
sudo docker 명령어는 Docker를 관리자 권한으로 실행하려고 할 때 사용합니다. Docker는 컨테이너 기반의 오픈소스 가상화 플랫폼입니다. Docker를 사용하면 개발환경, 라이브러리, 의존성 등을 컨테이너에 포장하여 어떤 환경에서도 동일하게 실행할 수 있습니다.

sudo docker 뒤에 다양한 서브커맨드와 옵션을 사용하여 Docker의 다양한 기능을 이용할 수 있습니다. 예를 들어:

sudo docker run: 이미지를 기반으로 새로운 컨테이너를 생성하고 실행합니다.
sudo docker ps: 현재 실행중인 컨테이너의 목록을 보여줍니다.
sudo docker pull: Docker 이미지를 다운로드합니다.
sudo docker build: Dockerfile을 기반으로 새로운 이미지를 생성합니다.
sudo docker stop: 실행중인 컨테이너를 중지합니다.
이러한 명령어를 사용하여 Docker를 이용할 수 있습니다. 도움이 필요하시면 추가 질문을 주시면 감사하겠습니다.
#######

도커 문서로 가서 어떻게 우분투에서 어떻게 도커를 설치하는지 보자 -> https://docs.docker.com/engine/install/ubuntu/
이부분을 참조하자

###########################
Install using the apt repository
Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.

Set up the repository
Update the apt package index and install packages to allow apt to use a repository over HTTPS:


 sudo apt-get update
 sudo apt-get install ca-certificates curl gnupg
Add Docker’s official GPG key:


 sudo install -m 0755 -d /etc/apt/keyrings
 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
 sudo chmod a+r /etc/apt/keyrings/docker.gpg
Use the following command to set up the repository:


 echo \
  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
Note

If you use an Ubuntu derivative distro, such as Linux Mint, you may need to use UBUNTU_CODENAME instead of VERSION_CODENAME.

Install Docker Engine
Update the apt package index:


 sudo apt-get update
Install Docker Engine, containerd, and Docker Compose.

Latest
Specific version

To install the latest version, run:


 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
Verify that the Docker Engine installation is successful by running the hello-world image.


 sudo docker run hello-world
This command downloads a test image and runs it in a container. When the container runs, it prints a confirmation message and exits.

You have now successfully installed and started Docker Engine.

Tip

Receiving errors when trying to run without root?

The docker user group exists but contains no users, which is why you’re required to use sudo to run Docker commands. Continue to Linux postinstall to allow non-privileged users to run Docker commands and for other optional configuration steps.

Upgrade Docker Engine
To upgrade Docker Engine, follow the installation instructions, choosing the new version you want to install.
##############################

도커가 깔렸으면 이제 portainer도 깔아보자 -> https://docs.portainer.io/start/install-ce/server/docker/linux
이전에 했던 방식대로 깔아보자 그런데 여기서 명령어 앞에 sudo를 붙여야한다 왜냐하면 root 유저로 접속한것이 아니라 ubuntu 유저로 접속한것이기 때문이다
-> sudo docker volume create portainer_data
그리고 sudo docker run -d -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
자 이러면 portainer 컨테이너가 깔린것을 확인할 수 있다 -> sudo docker container ls 

자 이제 포트와 아이피 주소를 이용해서 aws 의 portainer 컨테이너에 접속해보자 -> 54.215.96.40:9443
접속이 되지 않는다 포트가 막혀있기 때문이다 왜냐하면 ec2 인스턴스를 만들 때 기본적으로 ssh를 제외한 모든 포트를 firewall 로 막혀있기 때문이다 이 포트를 열어줘야한다 aws console 로 가서 ec2 인스턴스 페이지로 들어간다 
그리고 Security로 가서 Security groups 를 클릭한다 그리고 inbound rule을 수정해주면 된다 Type은 Custom TCP 그리고 source에 0.0.0.0/0 으로 해서 모든 아이피에서 접근 가능하게 했는데 특정 아이피로만 접속 가능하게 할 수 도 있다
그리고 다시 웹브라우저를 통해서 접속해본다 이상하게 내가 하면 portainer container를 재실행 하라고 나온다 그러면 sudo docker restart portainer 재실행해주고 접속하면 admin 계정으로 만들고 진행 가능하다
시작할 때 보니까 hello world 이미지랑 컨테이너가 디폴트로 깔려있네? ㅋㅋ 지워준다 그리고 마지막으로 swarm을 시작해준다 -> docker swarm init
이전에 VULTR 에서 할 때는 /home/django_course 디렉토리로 가서 swarm을 시작해줬는데 지금 이 디렉토리도 없고 강의도 그냥 /home/ubuntu 에 깔아줬으니 나도 그렇게 하자 

#############
질문: docker swarm init을 실행하는 디렉토리 위치가 중요해?
chat gpt
docker swarm init 명령은 현재 디렉토리의 위치와는 관계없이 실행됩니다. 이 명령은 현재 실행하는 Docker 데몬이 있는 시스템을 Docker Swarm의 관리자 노드(manager node)로 초기화합니다. 이 작업은 디렉토리 구조나 위치와는 독립적입니다.

이 명령을 실행하면, 해당 시스템은 Swarm 클러스터를 구성하고 관리하는 역할을 수행합니다. 또한 다른 노드들이 이 Swarm에 참가하도록 허용하며, Swarm에 배포된 서비스들을 조정합니다.

그러므로, docker swarm init 명령을 실행할 때는 디렉토리 위치보다는 Docker가 실행 중인 시스템과 그 시스템의 설정이 더 중요합니다.
###############
그래서 docker swarm init 을 실행하는 디렉토리는 관계 없다는건가?

이제 스택을 배포해야 하는데 그 전에 이전에 만들었었던 secret 들을 다시 만들어야 하고 nginx.conf 파일들 aws 서버에는 아직 없기 때문에 파일질라를 이용해서 aws 에 올려주도록 하자 
일단 portainer를 이용해 DJANGO_SECRET_KEY MARIADB_ROOT_PASSWORD MARIADB_PASSWORD 세개의 시크릿을 만들어 줬다 그리고 파일질라를 이용해 nginx.conf 를 올리려는데 여기서 이전과 다른 부분이 있다 
이전에는 파일질라에 아이피 유저네임 그리고 패스워드를 입력해 접속했다면 지금 우리는 ssh로 aws 접속시 pem 파일을 이용해 접속하고 있다 파일질라에서도 다른 방식으로 접속해야 한다 우선 파일질라 Host 라고 써 있는 부분 위쪽의 site manager 아이콘
을 클릭한다 그리고 new site를 눌러서 사이트 설정을 추가해보자 프로토콜은 SFTP 호스트에 aws 아이피 주소 포트는 22번 Logon Type 에 키 파일을 선택한다 User에 Ubuntu 그리고 키 파일을 선택해준다 그리고 Connect! 그러면 aws에 접속됬다
파일질라로 home 디렉토리 아래에 django_course 라는 디렉토리를 만들어주려 하는데 안된다 root 유저가 아니라 ubuntu 유저로 접속했기 때문이다 그러면 터미널로 가서 ssh로 다시 aws에 접속하자 그리고 home 디렉토리로 가서 
-> sudo mkdir django_course 이렇게 sudo 권한으로 django_course 디렉토리를 만들어준다 
자 이제 파일질라를 보면 django_course 디렉토리가 생겼다 하지만 그렇다고 nginx.conf 파일을 지금 옮길 수 있는것은 아니다 이것도 권한 문제이다 ubuntu 유저에게 권한을 추가적으로 주는 과정이 필요하다 
home 디렉토리로 가서 다음의 명령어를 입력하자 
-> sudo chmod 777 django_course/
이러면 ubuntu 유저에게 이 경로에서의 권한을 준거다 자 그러면 파일질라를 통해서 nginx.conf 를 /home/django_course 경로로 보내줄 수 있다 

자 그럼 이제 장고 이미지를 만들어준다 portainer 로 가서 기존에 했던거 처럼 dockerfile을 이용해서 장고 이미지를 만들어준다 그러면 이제 stack을 만들수 있다  




