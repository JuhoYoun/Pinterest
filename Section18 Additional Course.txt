AWS 과금 주의 
모든 것에 대해 돈을 내라 하고 졸라 비싸다 

추가적인 강의

1. AWS EC2 Deployment - 우리가 했던 과정을 VULTR 말고 AWS 에서 다시 해보기
2. Domain Configuration - 도메인을 사서 해당 도메인을 AWS EC2 instance 와 연결한다
3. HTTPS Configuration - HTTPS 보안 기능 
4. Github Private Repo - github repo를 private으로 돌렸을 우리가 해왔던 과정에 어떤 문제가 생기는지 ... 클론이나 그런 기능들을 하던 방식대로 사용할 수 없다
5. Like System Update - 좋아요 기능 추가 


AWS EC2 Deployment
 
VULTR의 경우 ssh로 접속할 때 id와 password를 인자로 넘겨줘 해당 서버에 접속했다 AWS에서는 보안상 PEM 같은 key file을 이용해서 서버에 접속하는것이 권장된다 (id/password 도 되긴한다)
VULTR에서는 도커가 이미 깔려있는 서버를 대여 받아 시작했지만 AWS 에는 도커가 깔려 있지 않아 직접 깔아줘야한다 
AWS도 포트가 있는데 default로 이 포트들이 방화벽으로 (firewall) 모두 막혀있다 때문에 포트를 사용해야할 때 포트를 열어주는 설정을 해줘야한다

일단 AWS 로 가서 콘솔 로그인을 한 다음 service -> EC2로 가자 
인스턴스를 만들기 이전에 key file을 먼저 만들어주자 좌측의 Network & Security 로 가서 Key pairs를 클릭 create key pair 를 누르고 pem 키를 만들어준다 이름은 맘대로 한다 
키 생성 동시에 pem 파일이 다운로드 된다 이 파일을 로컬의 프로젝트 루트 디렉토리로 옮기자 그리고 이 경로에서 ssh 접속을 할 수 있게 구축할것이다 (뭔말?)
그리고 instances 로 가서 launch instance를 누른다 ubuntu 20.0.4 를 선택 다른 것들 기본값으로 해준다 강의에서 보안 그룹 설정 단계가 포트를 관리하는 방화벽 설정 부분인데 지금 AWS 랑 다른가 보다 나한테 안보인다 
강의에서 포트는 우리가 필요할 때 마다 그 때 그 때 열어주기로 했다 키는 아까 만들었던 pem 키를 선택한다 그리고 인스턴스 시작해준다 

자 그러면 다운 받았던 pem 키를 이용해서 ssh 접속을 해보자 pem 키를 다운받았던 디렉토리로 가서 다음 명령어를 사용하낟
-> ssh -i aws_jake.pem ubuntu@54.215.96.40
ssh 로 pem 파일을 이용해 ubuntu 유저로 aws 주소로 접근한다는 의미이다 
#####
AWS EC2에서는 인스턴스에 따라 기본 사용자 이름이 다릅니다. Ubuntu 인스턴스의 경우, 기본 사용자 이름은 'ubuntu'이며, 이 계정을 통해 ssh 접속할 수 있습니다.

일반적으로 AWS EC2 인스턴스는 'root' 계정을 직접 사용하지 못하게 설정되어 있습니다. 대신, sudo 명령어를 사용하여 'ubuntu' 또는 다른 사용자 계정에서 root 권한을 얻을 수 있습니다
#####
그러면 지금은 처음 시도하는 거라서

The authenticity of host '54.215.96.40 (54.215.96.40)' can't be established.
ED25519 key fingerprint is SHA256:OOvvGghl080csg1bicigc3NpgNA511NFUAUXi5VYJBo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? 

이렇게 메세지가 뜬다 yes 를 타입해 접속하자
강의에서는 이러면 접속 되는데 나는 아래와 같은 에러 메세지가 뜬다
#########
The authenticity of host '54.215.96.40 (54.215.96.40)' can't be established.
ED25519 key fingerprint is SHA256:OOvvGghl080csg1bicigc3NpgNA511NFUAUXi5VYJBo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '54.215.96.40' (ED25519) to the list of known hosts.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions 0644 for 'aws_jake.pem' are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
Load key "aws_jake.pem": bad permissions
ubuntu@54.215.96.40: Permission denied (publickey).
##########
##########
위의 문제에 대한 chatgpt 해결법 진짜 먹힌다

이 오류 메시지는 개인키 파일의 권한이 너무 개방적으로 설정되어 있어, AWS가 이를 안전하지 않다고 판단한 것을 나타냅니다. AWS는 이 파일이 현재 사용자에게만 읽기 권한을 부여하도록 요구합니다.

이 문제를 해결하기 위해서는 파일 권한을 변경해야 합니다. 현재 사용자만이 이 파일을 읽을 수 있도록 파일 권한을 400 또는 600으로 설정하면 됩니다.

리눅스나 MacOS에서 다음 명령어를 실행하면 이를 수행할 수 있습니다:

bash
Copy code
chmod 400 aws_jake.pem
이 명령어를 실행한 후 다시 SSH 연결을 시도해보세요. 이제 AWS EC2 인스턴스에 연결할 수 있어야 합니다.
###############

연결되면 일단 도커가 깔려 있는지 확인한다 
-> sudo docker 또는 docker
도커가 안깔려 있는걸 볼 수 있다 도커를 깔아줘야한다

#######
chat gpt
sudo docker 명령어는 Docker를 관리자 권한으로 실행하려고 할 때 사용합니다. Docker는 컨테이너 기반의 오픈소스 가상화 플랫폼입니다. Docker를 사용하면 개발환경, 라이브러리, 의존성 등을 컨테이너에 포장하여 어떤 환경에서도 동일하게 실행할 수 있습니다.

sudo docker 뒤에 다양한 서브커맨드와 옵션을 사용하여 Docker의 다양한 기능을 이용할 수 있습니다. 예를 들어:

sudo docker run: 이미지를 기반으로 새로운 컨테이너를 생성하고 실행합니다.
sudo docker ps: 현재 실행중인 컨테이너의 목록을 보여줍니다.
sudo docker pull: Docker 이미지를 다운로드합니다.
sudo docker build: Dockerfile을 기반으로 새로운 이미지를 생성합니다.
sudo docker stop: 실행중인 컨테이너를 중지합니다.
이러한 명령어를 사용하여 Docker를 이용할 수 있습니다. 도움이 필요하시면 추가 질문을 주시면 감사하겠습니다.
#######

도커 문서로 가서 어떻게 우분투에서 어떻게 도커를 설치하는지 보자 -> https://docs.docker.com/engine/install/ubuntu/
이부분을 참조하자

###########################
Install using the apt repository
Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.

Set up the repository
Update the apt package index and install packages to allow apt to use a repository over HTTPS:


 sudo apt-get update
 sudo apt-get install ca-certificates curl gnupg
Add Docker’s official GPG key:


 sudo install -m 0755 -d /etc/apt/keyrings
 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
 sudo chmod a+r /etc/apt/keyrings/docker.gpg
Use the following command to set up the repository:


 echo \
  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
Note

If you use an Ubuntu derivative distro, such as Linux Mint, you may need to use UBUNTU_CODENAME instead of VERSION_CODENAME.

Install Docker Engine
Update the apt package index:


 sudo apt-get update
Install Docker Engine, containerd, and Docker Compose.

Latest
Specific version

To install the latest version, run:


 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
Verify that the Docker Engine installation is successful by running the hello-world image.


 sudo docker run hello-world
This command downloads a test image and runs it in a container. When the container runs, it prints a confirmation message and exits.

You have now successfully installed and started Docker Engine.

Tip

Receiving errors when trying to run without root?

The docker user group exists but contains no users, which is why you’re required to use sudo to run Docker commands. Continue to Linux postinstall to allow non-privileged users to run Docker commands and for other optional configuration steps.

Upgrade Docker Engine
To upgrade Docker Engine, follow the installation instructions, choosing the new version you want to install.
##############################

도커가 깔렸으면 이제 portainer도 깔아보자 -> https://docs.portainer.io/start/install-ce/server/docker/linux
이전에 했던 방식대로 깔아보자 그런데 여기서 명령어 앞에 sudo를 붙여야한다 왜냐하면 root 유저로 접속한것이 아니라 ubuntu 유저로 접속한것이기 때문이다
-> sudo docker volume create portainer_data
그리고 sudo docker run -d -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
자 이러면 portainer 컨테이너가 깔린것을 확인할 수 있다 -> sudo docker container ls 

자 이제 포트와 아이피 주소를 이용해서 aws 의 portainer 컨테이너에 접속해보자 -> 54.215.96.40:9443
접속이 되지 않는다 포트가 막혀있기 때문이다 왜냐하면 ec2 인스턴스를 만들 때 기본적으로 ssh를 제외한 모든 포트를 firewall 로 막혀있기 때문이다 이 포트를 열어줘야한다 aws console 로 가서 ec2 인스턴스 페이지로 들어간다 
그리고 Security로 가서 Security groups 를 클릭한다 그리고 inbound rule을 수정해주면 된다 Type은 Custom TCP 그리고 source에 0.0.0.0/0 으로 해서 모든 아이피에서 접근 가능하게 했는데 특정 아이피로만 접속 가능하게 할 수 도 있다
그리고 다시 웹브라우저를 통해서 접속해본다 이상하게 내가 하면 portainer container를 재실행 하라고 나온다 그러면 sudo docker restart portainer 재실행해주고 접속하면 admin 계정으로 만들고 진행 가능하다
시작할 때 보니까 hello world 이미지랑 컨테이너가 디폴트로 깔려있네? ㅋㅋ 지워준다 그리고 마지막으로 swarm을 시작해준다 -> docker swarm init
이전에 VULTR 에서 할 때는 /home/django_course 디렉토리로 가서 swarm을 시작해줬는데 지금 이 디렉토리도 없고 강의도 그냥 /home/ubuntu 에 깔아줬으니 나도 그렇게 하자 

#############
질문: docker swarm init을 실행하는 디렉토리 위치가 중요해?
chat gpt
docker swarm init 명령은 현재 디렉토리의 위치와는 관계없이 실행됩니다. 이 명령은 현재 실행하는 Docker 데몬이 있는 시스템을 Docker Swarm의 관리자 노드(manager node)로 초기화합니다. 이 작업은 디렉토리 구조나 위치와는 독립적입니다.

이 명령을 실행하면, 해당 시스템은 Swarm 클러스터를 구성하고 관리하는 역할을 수행합니다. 또한 다른 노드들이 이 Swarm에 참가하도록 허용하며, Swarm에 배포된 서비스들을 조정합니다.

그러므로, docker swarm init 명령을 실행할 때는 디렉토리 위치보다는 Docker가 실행 중인 시스템과 그 시스템의 설정이 더 중요합니다.
###############
그래서 docker swarm init 을 실행하는 디렉토리는 관계 없다는건가?

이제 스택을 배포해야 하는데 그 전에 이전에 만들었었던 secret 들을 다시 만들어야 하고 nginx.conf 파일들 aws 서버에는 아직 없기 때문에 파일질라를 이용해서 aws 에 올려주도록 하자 
일단 portainer를 이용해 DJANGO_SECRET_KEY MARIADB_ROOT_PASSWORD MARIADB_PASSWORD 세개의 시크릿을 만들어 줬다 그리고 파일질라를 이용해 nginx.conf 를 올리려는데 여기서 이전과 다른 부분이 있다 
이전에는 파일질라에 아이피 유저네임 그리고 패스워드를 입력해 접속했다면 지금 우리는 ssh로 aws 접속시 pem 파일을 이용해 접속하고 있다 파일질라에서도 다른 방식으로 접속해야 한다 우선 파일질라 Host 라고 써 있는 부분 위쪽의 site manager 아이콘
을 클릭한다 그리고 new site를 눌러서 사이트 설정을 추가해보자 프로토콜은 SFTP 호스트에 aws 아이피 주소 포트는 22번 Logon Type 에 키 파일을 선택한다 User에 Ubuntu 그리고 키 파일을 선택해준다 그리고 Connect! 그러면 aws에 접속됬다
파일질라로 home 디렉토리 아래에 django_course 라는 디렉토리를 만들어주려 하는데 안된다 root 유저가 아니라 ubuntu 유저로 접속했기 때문이다 그러면 터미널로 가서 ssh로 다시 aws에 접속하자 그리고 home 디렉토리로 가서 
-> sudo mkdir django_course 이렇게 sudo 권한으로 django_course 디렉토리를 만들어준다 
자 이제 파일질라를 보면 django_course 디렉토리가 생겼다 하지만 그렇다고 nginx.conf 파일을 지금 옮길 수 있는것은 아니다 이것도 권한 문제이다 ubuntu 유저에게 권한을 추가적으로 주는 과정이 필요하다 
home 디렉토리로 가서 다음의 명령어를 입력하자 
-> sudo chmod 777 django_course/
이러면 ubuntu 유저에게 이 경로에서의 권한을 준거다 자 그러면 파일질라를 통해서 nginx.conf 를 /home/django_course 경로로 보내줄 수 있다 

자 그럼 이제 장고 이미지를 만들어준다 portainer 로 가서 기존에 했던거 처럼 dockerfile을 이용해서 장고 이미지를 만들어준다 그러면 이제 stack을 만들수 있다  
stack 이 완성되면 aws console 로 가서 80번 포트를 열어준다 그러면 이제 aws 아이피주소인 54.215.96.40 으로 aws에 배포한 웹사이트에 접근이 가능하다 

이제 HTTPS 보안 설정 하는 법을 배워보자 HTTPS 는 도메인 기반의 기술이라 도메인을 먼저 연결해줘야한다 강의에서는 gabia 라는 도메인 업체를 사용했다 도메인을 구입하면 이 도메인을 aws 의 route53 이라는 서비스에 연결할것이다 
그리고 route53 에서 우리가 돌리가 있는 ec2 인스턴스로 연결시켜주는 작업을 할것이다 일단 aws console로 가서 servie -> networking & content delivery -> route 53으로 간다 
그리고 DNS management 아래 Create hosted zone을 클릭 거기에 산 도메인을 적고 Public hosted zone 을 선택하고 create 하면 된다 Private hosted zone 같은 경우 아마존 내부에서 쓰는 도메인을 새로 설정하는 느낌이다
Hosted zone 을 보면 타입에 NS 라는게 있는데 name server 란 뜻이다 이게 아마존에서 이 도메인으로 설정해준 name server 인데 도메인과 route 53 을 연결해주는 사이 정도로 생각하면 된다
gabia에 가서 도메인 변경을 누르고 이 name server들을 입력해주자 이러면 도메인과 route 53을 연결했다 
이제 route 53과 ec2를 연결해주는 과정이 필요하다 방금 등록한 hosted zone 을 클릭해서 들어가면 create record를 눌러서 새 레코드를 생성해야한다 sub domain에는 원한다면 www 를 넣어도 되고 value에는 ec2 인스턴스의 아이피를 넣는다
나머지 레코드 타입은 A 라우팅 폴리시는 simple routing 그리고 TTL도 300 이렇게 디폴트 값 그대로 놔두고 create record! 이제 시간이 좀 지나면 도메인으로 검색했을 때 웹사이트가 뜨는걸 볼 수 있다 강의에서는 www 안넣고 했었는데 나중에 강사
가 www 넣은 레코드도 하나 더 넣으라고 했다

HTTPS Configuration
AWS 에서 HTTPS를 쓰는 법을 배워보자 HTTPS는 HTTP의 보안 버전이라 생각하면 된다 HTTP로 POST 요청을 보낼 때 BODY 안에 추가적으로 넣은 정보들을 (게시글 사진 아이디 패스워드 등등) 넣어서 요청한다 이 POST 요청이 어떻게
서버로 전달되냐면 단순히 유저가 서버에 보내고 끝내는게 아니라 네트워크 안에는 수많은 서버가 있고 우리가 타게팅한 그 서버로 전달되기 위해서는 여러가지 서버를 거치게 된다 문제는 중간 단계에 있는 서버에서 해커라던지 중간 탈취자가 그 정보를
들여도 볼 수 있다 일반 HTTP 프로토콜에선 이게 가능하다 하지만 HTTPS 는 BODY 안의 내용들을 암호화한다 때문에 중간에 누가 들여다 봐도 무슨 내용인지 모르게한다

AWS에서는 Load balancer 라는것을 만들어줘야 HTTPS를 사용할 수 있다 최근 추세는 서버에 부하를 줄이려고 같은 서버를 여러개 두는 scale out 방식으로 보강을 한다 이 때 서버들이 다 정상적으로 동작하도록 부하 분산을 해주는게 중요하다 
이렇게 부하를 분산해주는게 로드 밸런서이다 이제 aws에서 로드 밸런서를 만들어보자 services -> ec2 로 가면 왼쪽에 Load Balacning 이라고 써있는게 있다 그 아래에 Load Balancer 를 클릭한다 그리고 create load balancer 클릭
그리고 http https 로드밸런서 타입을 선택해준다 Application Load Balancer 와 Network Load Balancer 는 OSI 계층상에서 어느 계층에서 동작하는지를 간단하게 표현한거다 이름은 jake_balancer 라고 하고 ip address 타입은
ipv4를 선택했다 scheme 은 internet-facing 그대로 한다 그리고 리스너는 HTTP 가 디폴트로 있는데 HTTPS도 추가해준다 그리고 Network mapping에 mapping에는 두개 다 선택해준다 
HTTPS는 보안용 프로토콜이기 때문에 인증서가 필요하다 aws를 사용하면 알아서 만들어주는 방식이다 Default SSL/TLS certificate 섹션에 자동으로 되있는 From ACM 으로 하면 우리가 설정한 도메인을 인증해주는 인증서를 자동으로 발급해주고
그것을 관리해준다 Security groups 설정은 ec2 인스턴스로 들어가서 ec2 인스턴스가 어떤 보안그룹으로 설정되있는지 확인하고 같은 보안 그룹으로 설정해준다 
Listeners and routing 섹션으로 가면 create target group이 있는지 그걸 눌러서 새 대상그룹을 만들어준다 이름은 강의처럼 그냥 webserver 라고 하고 target type은 우리는 ec2랑 연결하는거니까 instance로 해준다 
Next 를 눌러면 Register targets이 나오는데 Available instances 에 우리가 연결하고 싶은 ec2 를 선택해주고 include as pending below를 누르면 Targets 리스트 안에 들어간다 로드밸런스에 연결될 인스턴스를 등록한거다
그리고 create target group을 누르면 target group이  생성된다  아까 추가한 리스너 두개 HTTP 와 HTTPS 의 Default action 으로 방금 만든 webserver target group을 선택해준다 
그리고 보다보니 강의때의 aws 랑 지금 aws가 많이 다르다 Default SSL/TLS certificate 여기에 From ACM 옆에 Select a certificate 이라고 되있는데 강의에서는 이 부분이 자동으로 채워져있는데 내가할 때는 비어있다 
나는 Request new ACM certificate 를 눌러서 Request a certificate 누른후 Fully qualified domain name 여기에 내 도메인 치고 나머지는 디폴트로 하고 request 눌러서 certificate 을 request 해줬다 
그리고 해당 certificate이 펜딩이라고 나오는데 일단 certificate 클릭하고 들어가서 Create records in Route 53  이걸 눌러서 해당 도메인으로 레코드를 만들어줬더니 이제 로드밸런서 생성시 certificate 입력하는 곳에 방금 만든 
certificate이 떠서 선택할 수 있었다 그리고 로드밸런서 생성 버튼을 눌러 생성한다 여기가 끝이 아니다 route 53 으로 가서 해당 hosted zone 으로 가서 레코드를 추가해준다 레코드네임에는 www.teddyyounhan.com 레코드 타입 A 그리고
alias 에 체크해주고 application classic load balancer 선택 그리고 지역 선택한 후 우리가 만든 로드밸런서를 선택해준다 강의에서는 evaluate target health 도 체크해줬다 나는 이미 만들어논 www.teddyyounhan.com 레코드가 있어서
이를 에딧해줬다 그리고 마지막으로 ec2 인스턴스의 443 포트를 열어주자 자 이렇게 하면 강의에서는 웹사이트에 https로 접속하면 https 가 되고 인증서도 잘 되는데 나는 인증서가 valid 하지 않다고 뜬다 왜이럴까?
 
##########################
chatgpt에 물어본 aws https 설정 과정 

1단계: EC2 인스턴스 생성 및 설정

AWS에서 EC2 인스턴스를 생성하는 과정은 다음과 같습니다. 이 예제에서는 Amazon Linux 2 AMI를 사용하겠습니다.

EC2 대시보드로 이동: AWS Management Console에 로그인한 후, 서비스 메뉴에서 "EC2"를 선택합니다.

인스턴스 생성: EC2 대시보드에서 "인스턴스" 메뉴를 선택한 후, "인스턴스 시작" 버튼을 클릭합니다.

AMI 선택: "Amazon Linux 2 AMI (HVM), SSD Volume Type"을 선택하고, "다음: 인스턴스 유형 선택"을 클릭합니다.

인스턴스 유형 선택: 웹사이트의 규모에 따라 적절한 인스턴스 유형을 선택합니다. 예를 들어, "t2.micro"는 소규모 웹사이트에 적합합니다. "다음: 인스턴스 세부 정보 구성"을 클릭합니다.

인스턴스 세부 정보 구성: 기본값을 사용하거나 필요에 따라 세부 정보를 수정한 후, "다음: 스토리지 추가"를 클릭합니다.

스토리지 추가: 필요에 따라 스토리지 크기를 변경하거나 추가 스토리지를 추가한 후, "다음: 태그 추가"를 클릭합니다.

태그 추가: 원하는 경우 태그를 추가하고, "다음: 보안 그룹 구성"을 클릭합니다.

보안 그룹 구성: 새 보안 그룹을 생성하고, 웹 트래픽을 받기 위해 HTTP와 HTTPS를 허용하도록 설정합니다. 또한 SSH를 허용하여 인스턴스에 접근할 수 있도록 합니다. "검토 및 시작"을 클릭합니다.

검토 및 시작: 모든 설정을 검토한 후, "시작"을 클릭합니다.

키페어 생성 또는 선택: 새 키페어를 생성하거나 기존 키페어를 사용하여 인스턴스에 접속할 수 있게 합니다. 키페어를 생성하면 개인 키 파일 (.pem)을 다운로드해야 합니다. 이 키는 분실하면 다시 얻을 수 없으므로 안전하게 보관해야 합니다.

이제 EC2 인스턴스가 시작되고, "인스턴스 상태"를 체크하면 인스턴스가 "실행 중" 상태인 것을 확인할 수 있습니다.

다음 단계는 웹 서버(예: Apache 또는 Nginx)를 설정하는 것입니다. 이에 대해 자세히 알려드릴까

"다음 단계는 웹 서버(예: Apache 또는 Nginx)를 설정하는 것입니다. 이에 대해 자세히 알려드릴까" 아까 말한 이 부분도 자세히 설명 가능할까?

웹 서버를 설정하는 과정은 다음과 같습니다. 여기서는 대표적인 웹 서버인 Apache와 Nginx에 대해 설명하겠습니다. 두 웹 서버 모두 HTTP 및 HTTPS 요청을 처리하는 데 사용됩니다.

Apache 웹 서버 설정:

먼저, EC2 인스턴스에 SSH로 접속합니다.

Apache를 설치합니다. Ubuntu 시스템에서는 다음 명령을 사용합니다:

bash
Copy code
sudo apt update
sudo apt install apache2
Apache가 제대로 설치되고 실행되었는지 확인합니다:
bash
Copy code
sudo systemctl status apache2
이제 Apache의 설정 파일을 편집해야 합니다. 이 파일에서는 웹사이트의 루트 디렉토리, 로그 파일의 위치, 서버 이름 등을 설정할 수 있습니다. Ubuntu에서는 기본 설정 파일이 다음 위치에 있습니다:
bash
Copy code
/etc/apache2/sites-available/000-default.conf
이 파일을 편집하기 위해 다음 명령을 사용할 수 있습니다:

bash
Copy code
sudo nano /etc/apache2/sites-available/000-default.conf
마지막으로 Apache 설정을 적용하려면 Apache를 재시작해야 합니다:
bash
Copy code
sudo systemctl restart apache2
Nginx 웹 서버 설정:

먼저, EC2 인스턴스에 SSH로 접속합니다.

Nginx를 설치합니다. Ubuntu 시스템에서는 다음 명령을 사용합니다:

bash
Copy code
sudo apt update
sudo apt install nginx
Nginx가 제대로 설치되고 실행되었는지 확인합니다:
bash
Copy code
sudo systemctl status nginx
이제 Nginx의 설정 파일을 편집해야 합니다. 이 파일에서는 웹사이트의 루트 디렉토리, 로그 파일의 위치, 서버 이름 등을 설정할 수 있습니다. Ubuntu에서는 기본 설정 파일이 다음 위치에 있습니다:
bash
Copy code
/etc/nginx/sites-available/default
이 파일을 편집하기 위해 다음 명령을 사용할 수 있습니다:

bash
Copy code
sudo nano /etc/nginx/sites-available/default
마지막으로 Nginx 설정을 적용하려면 Nginx를 재시작해야 합니다:
bash
Copy code
sudo systemctl restart nginx
위의 설정은 기본적인 웹 서버 설정입니다. 웹사이트의 세부 요구사항에 따라 설정을 추가하거나 변경해야 할 수 있습니다. 추가적인 설정에는 보안 설정, 성능 최적화, 리디렉션 설정 등이 있습니다.

2단계: Route 53을 사용하여 도메인 설정

Route 53을 사용하여 도메인을 설정하려면 다음 단계를 따르면 됩니다:

1단계: 도메인 이름 등록

AWS Management Console에 로그인하고, "Route 53" 서비스를 찾아서 클릭합니다.
대시보드에서 "도메인 등록"을 클릭합니다.
새 도메인 이름을 검색하고 사용 가능한 경우, 등록 절차를 따라 진행합니다.
도메인을 성공적으로 등록하면 Route 53에서 자동으로 DNS 설정을 생성합니다.
이미 도메인이 등록되어 있다면 이 단계를 건너뛰어도 됩니다.

2단계: 호스팅 영역 생성

Route 53 대시보드에서 "DNS 관리"를 클릭합니다.
"호스팅 영역 생성"을 클릭합니다.
"영역 이름"에 도메인 이름을 입력하고, "공용 호스팅 영역"을 선택한 후, "영역 생성"을 클릭합니다.
3단계: 레코드 세트 생성

새로 생성한 호스팅 영역으로 이동합니다.
"레코드 세트 생성"을 클릭합니다.
"이름" 필드는 비워두고, "유형"은 "A - IPv4 주소"를 선택합니다.
"값" 필드에 EC2 인스턴스의 퍼블릭 IP 주소를 입력합니다.
"레코드 세트 생성"을 클릭합니다.
이제 도메인 이름이 EC2 인스턴스를 가리키도록 설정되었습니다. DNS 변경 사항이 전파되는 데는 일반적으로 최대 24시간까지 걸릴 수 있습니다. 이 변경 사항이 전파되면, 웹 브라우저에서 도메인 이름을 입력하면 EC2 인스턴스가 제공하는 웹사이트에 접속할 수 있습니다.

다음 단계는 AWS Certificate Manager에서 SSL/TLS 인증서를 받는 것입니다. 이에 대해 자세히 알려드릴까요?

3단계: AWS Certificate Manager에서 SSL/TLS 인증서 받기

AWS Certificate Manager (ACM)를 사용하여 SSL/TLS 인증서를 받는 방법은 다음과 같습니다:

1단계: ACM 대시보드로 이동

AWS Management Console에 로그인한 후, "Certificate Manager" 서비스를 찾아서 클릭합니다.
2단계: 인증서 요청

"Get started" 버튼 아래의 "Provision certificates" 카드를 클릭합니다.
"Request a public certificate"를 클릭하고, "Request a certificate" 버튼을 클릭합니다.
3단계: 도메인 이름 추가

인증서를 사용할 도메인 이름을 "Add domain names" 항목에 입력합니다. 이 때, www를 포함하거나, 와일드카드를 사용하여 서브도메인을 포함하는 등, 다양한 패턴이 가능합니다.
"Next"를 클릭합니다.
4단계: 검증 방법 선택

인증서를 발급받기 위해서는 도메인 소유권을 검증해야 합니다. "Validation method"에서 "DNS validation"을 선택하고, "Review"를 클릭합니다.
5단계: 검증

요약 화면에서 "Confirm and request"를 클릭하여 인증서 요청을 완료합니다.
인증서 요청이 완료되면, 인증서 목록에서 방금 요청한 인증서를 클릭하여 상세 화면으로 이동합니다. 여기에서 "Create record in Route 53"를 클릭하여 자동으로 DNS 레코드를 생성할 수 있습니다. 이 레코드는 ACM이 도메인 소유권을 확인하는 데 사용됩니다.
DNS 레코드가 제대로 생성되었는지 확인하기 위해, Route 53 대시보드의 해당 도메인의 레코드 세트를 확인할 수 있습니다.
DNS 변경 사항이 전파되는 데는 최대 72시간까지 걸릴 수 있습니다. ACM은 이 시간이 지난 후에 도메인 소유권을 확인하고 인증서를 발급합니다. 이 변경 사항이 전파되면, ACM 대시보드에서 인증서 상태가 "Issued"로 변경되는 것을 확인할 수 있습니다.

다음 단계는 Elastic Load Balancer를 설정하고 HTTPS 리디렉션을 설정하는 것입니다. 이에 대해 자세히 알려드릴까요?

4단계: Elastic Load Balancer 설정 및 HTTPS 리디렉션 설정

Elastic Load Balancer (ELB)를 설정하고 HTTPS 리디렉션을 설정하는 과정은 다음과 같습니다:

1단계: ELB 생성

AWS Management Console에 로그인한 후, "EC2" 서비스를 찾아서 클릭합니다.
왼쪽의 네비게이션 패널에서 "로드 밸런서"를 클릭합니다.
"로드 밸런서 생성"을 클릭합니다.
"HTTP/HTTPS (Application Load Balancer)"를 선택하고, "로드 밸런서 생성"을 클릭합니다.
2단계: 로드 밸런서 설정

로드 밸런서의 이름을 입력하고, 스킴은 "인터넷 대면"을 선택합니다.
리스너를 추가합니다. 기본적으로 HTTP 리스너가 추가되어 있을 것입니다. HTTPS 리스너를 추가하려면 "리스너 추가"를 클릭하고, "HTTPS"를 선택하고, ACM에서 발급받은 인증서를 선택합니다.
가용 영역을 선택합니다. EC2 인스턴스와 동일한 가용 영역을 선택해야 합니다.
"다음: 보안 그룹 구성"을 클릭합니다.
3단계: 보안 그룹 구성

보안 그룹을 선택하거나 새로 생성합니다. 이 보안 그룹은 HTTP와 HTTPS를 허용해야 합니다.
"다음: 라우팅 구성"을 클릭합니다.
4단계: 라우팅 구성

새 타깃 그룹을 생성하고, 타깃 유형은 "인스턴스"를 선택합니다.
"다음: 타깃 등록"을 클릭합니다.
5단계: 타깃 등록

EC2 인스턴스를 선택하여 타깃으로 추가합니다.
"다음: 검토"를 클릭합니다.
6단계: 검토 및 생성

설정을 검토하고, "생성"을 클릭합니다.
이제 ELB가 생성되었고, ACM에서 발급받은 SSL/TLS 인증서를 사용하여 HTTPS 트래픽을 처리하도록 설정되었습니다.

HTTPS 리디렉션 설정

HTTPS 리디렉션은 HTTP 트래픽을 HTTPS로 자동 리디렉션하는 것입니다. 이는 사용자가 HTTP로 접속한 경우 자동으로 HTTPS로 리디렉션되어 보안 연결이 이루어지게 하는 것입니다.

ELB 대시보드에서 생성한 로드 밸런서를 선택합니다.
"리스너" 탭을 클릭합니다.
HTTP (포트 80)에 대한 리스너를 선택하고, "보기/편집 규칙"을 클릭합니다.
"규칙 추가"를 클릭합니다.
"요청을 리디렉션하려면"을 선택하고, 프로토콜을 "HTTPS"로 설정합니다. 상태 코드는 "HTTP_301"을 선택합니다.
"확인"을 클릭하고, "규칙 업데이트"를 클릭하여 리디렉션 규칙을 저장합니다.
이제 웹사이트에 HTTP로 접속하면 자동으로 HTTPS로 리디렉션됩니다.

마지막 단계는 Route 53에서 도메인 이름을 로드 밸런서로 리디렉션하는 것입니다. 이에 대해 자세히 알려드릴까요?

Route 53에서 도메인 이름을 로드 밸런서로 리디렉션하는 과정은 다음과 같습니다:

1단계: Route 53으로 이동

AWS Management Console에 로그인한 후, "Route 53" 서비스를 찾아서 클릭합니다.
2단계: 호스팅 영역 선택

"DNS 관리"를 클릭하고, 웹사이트의 도메인 이름에 해당하는 호스팅 영역을 선택합니다.
3단계: 레코드 세트 생성 또는 수정

웹사이트를 가리키도록 설정한 레코드 세트 (A 레코드)를 찾습니다. 그 레코드 세트를 수정하거나, 없다면 새로 생성합니다.
4단계: 레코드 세트 설정

"레코드 세트 세부 정보"에서 "유형"을 "A - IPv4 주소"로 설정하고, "별칭"을 "예"로 설정합니다.
"별칭 대상"에서 방금 생성한 Elastic Load Balancer 인스턴스를 선택합니다. 해당 인스턴스는 선택 박스에서 로드 밸런서의 이름과 함께 표시됩니다.
"별칭 DNS 이름:"이 로드 밸런서의 DNS 이름과 일치하는지 확인합니다.
"별칭 호스트 지역"이 로드 밸런서와 동일한 리전에 있는지 확인합니다.
5단계: 레코드 세트 저장

"변경 내용" 버튼을 클릭하여 레코드 세트를 저장합니다.
이제 도메인 이름이 로드 밸런서를 가리키게 되었으며, 로드 밸런서는 EC2 인스턴스로 트래픽을 분배하게 됩니다. 이 설정으로 인해 웹사이트는 HTTP와 HTTPS 요청 모두를 처리할 수 있게 되었습니다.

최종적으로, DNS 변경 사항이 전파되는 데는 최대 24시간까지 소요될 수 있습니다. 변경 사항이 전파된 후에는 도메인 이름을 웹 브라우저에 입력하면 HTTPS를 통해 웹사이트에 접속할 수 있습니다. HTTP를 통해 접속하려고 하면 자동으로 HTTPS로 리디렉션됩니다.







