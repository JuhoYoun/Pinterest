NGINX - 웹서버 소프트웨어. 클라이언트가 요청한 부분을 처리하는 서버 소프트웨어.
Docker - 배포에 있어서 가장 중요한 기술중 하나. 장고 서비스 하나가 도커의 하나의 컨테이너가 된다. 이렇게 만든 장고 컨테이너를 전체 도커 시스템에 밀어넣을것이다. 다른 도커 시스템으로는
마리아 DB 컨테이너, NGINX 서버 컨테이너, Certbot 컨테이너 등이있다.
VULTR(벌처) - 가상 서버 대여업체. 도커시스템이 완성되면 이것을 벌처에서 실재 서버를 빌려서 우리가 만든 도커 시스템을 올려 배포할것이다. 
django-admin -> 이 커맨드를 입력하면 django-admin 을 이용하여 할 수 있는 명령어들이 나온다. 
venv 가상 환경이 활성화 되어있을 시 프로젝트 디렉토리 말고도 모든 디렉토리에 venv가 적용된다

Pycharm 단축키 꿀팁
If there's an error in the code, pressing ⌥⏎ (option + enter) (macOS), or Alt+Enter (Windows/Linux), can suggest options that will make the code compile.
-> 만약 어떤 메소드가 아직 import 되지 않았다면 어떤 패키지에서 import 해야하는지도 suggest 함

gitgub 의 gitignore 레포지토리에서는 gitignore 파일을 위한 다양한 템플릿을 제공해준다 이 프로젝트에서는 Global 폴더의 Jetbrains.gitignore 템플릿을 사용하자 (Pycharm IDE 사용하기 때문)

프로젝트 앱의 settings.py 파일을 보면 다음과 같은 변수가 있다
# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure--5ej32jnwnzn%jv$gb)z@=e1c@(lvtha!1&o9o9%2z4p4_n16s"

이 시크릿 키는 장고 애플리케이션에 하나 씩 배정되고 배포할 때 노출 시키면 안된다. 때문에 파일을 따로 만들어 이 키를 불러 오는 형식으로 다시 만들자. 이를 위한 라이브러리가 이미 존재한다. 
-> django-environ -> https://django-environ.readthedocs.io/en/latest/index.html

pip install django-environ 설치한다 그리고 다큐먼트에 써있는대로 해보자

Pycharm의 VCS 탭을 누르면 Enable Version Control Integration 이 보이는데 이를 이용하면 Git 을 활성화할 수 있다.

Hyper Text : 문서간 이동이 가능하다
Markup : 써 내려간다

Django Template

1. extend / include
- extends는 기본 템플릿을 만들어 놓고 그것을 가져와서 연정해서 내용을 채워나간다. include 우리가 만들고 있는 html 파일이 있다고 하면은 거기다가 조그만 조각같은 것을 가져와 템플릿 안에다가 박아 넣는다. 즉 extends로 뼈대를 가져오고 include 로 채워넣는다. 이렇게 나온 결과물이 response view.

2. template 파일의 경로 경로 디렉토리 설정은 settings.py 에서 할 수 있다. -> "DIRS": [os.path.join(BASE_DIR, 'templates')],

3. include 로 가지고올 부분은 파일을 따로 만들어준다 ex) head.html

4. div 는 가능한 폭을 모두 가져가는 태그라고 생각하면 된다 

5. Pycharm 에서 option key + 커서로 지정한 부분들은 동시에 작업이 가능하다 (꿀팁!)


질문. 9강 들은 후 의문점이 있어서 질문드립니다. settings.py 파일에 분명 프로젝트 루트의 templates 폴더로 기본 템플릿 디렉토리 경로를 설정하였는데 ("DIRS": [os.path.join(BASE_DIR, 'templates')],)  accountapp 디렉토리의 view.py 파일에서 html를 렌더링 할 때 (return render(request, 'accountapp/hello_world.html')) 어떻게 'accountapp/hello_world.html' 이라는 input 으로 accountapp/templates/accountapp 경로에 있는 hello_world.html 파일에 접근할 수 있나요?

Chatgpt 답: 

In Django, the web framework looks for templates in a specified set of directories, which are defined in the TEMPLATES setting in the project's settings.py file. By default, Django looks for templates in the templates/ directory of each installed application.

Here's how Django finds the template path:

First, Django looks for the APP_DIRS setting in the TEMPLATES setting. If APP_DIRS is set to True, Django will look for templates in the templates/ directory of each installed application.

If APP_DIRS is False, Django will look for templates in the directories specified in the DIRS setting in the TEMPLATES setting.

If neither APP_DIRS nor DIRS is specified, Django will use a default set of directories: os.path.join(BASE_DIR, 'templates').

BASE_DIR is a setting that specifies the base directory of the project. By default, it is the directory containing the project's settings.py file.

Once Django has determined the set of directories to look for templates, it searches for the template file in each directory in order, looking for a file with the specified name and file extension. If it finds a match, it uses that template to render the response.

In addition to the default behavior, you can also customize the template loading process by writing your own template loaders, which can load templates from alternative sources such as a database or a remote file system.

질문. Can you explain this python code Path(__file__).resolve().parent.parent

Chatgpt 답:
This Python code uses the pathlib module to obtain the path of the current file's parent directory's parent directory. Here's how it works:

Path(__file__) creates a Path object that represents the path of the current file.
.resolve() resolves any symbolic links, references to parent directories (i.e., ..), and returns an absolute path. This ensures that the path is fully resolved and not a relative path that depends on the current working directory.
.parent returns the parent directory of the resolved path, which is the directory containing the current file.
.parent is called again to obtain the parent directory of the directory containing the current file, which is the directory containing the parent directory.
So, the resulting expression Path(__file__).resolve().parent.parent gives you the path of the parent directory's parent directory of the current file.

This is a useful technique to locate files relative to the current file's location, especially if you need to access other files in the same directory as the current file or in a parent directory.


부트스트랩은 html 의 스타일을 그럴듯하게 만들어주는 라이브러리
get started -> https://getbootstrap.com/docs/5.3/getting-started/introduction/

Google Fonts -> 폰트 링크들을 받을 수 있다
https://fonts.google.com/?preview.text=Jake%27s%20Home&preview.text_type=custom

Static
settings.py 파일로 가서 STATIC_URL 라인 밑에 다음과 같이 STATIC_ROOT 를 추가하자 
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
나중에 python3 manage.py collectstatic 이라는 명령어를 통해 STATIC_ROOT로 프로젝트 안의 모든 static 파일들을 모아준다.

